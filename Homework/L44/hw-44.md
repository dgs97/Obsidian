# Цель: Углубленное изучение основных концепций Kubernetes, связанных с Namespaces, Pods и Controllers.

## Задание:
### 0. Создание кластера GKE:

```bash
# Установите проект по умолчанию (замените YOUR-PROJECT-ID на ID вашего проекта)
gcloud config set project hw-44-471015
sudo apt-get install kubectl
# Включите необходимые сервисы (если делаете впервые)
gcloud services enable container.googleapis.com

# Создайте кластер в зоне europe-west3(можно изменить)
gcloud container clusters create-auto hw-44-cluster --location europe-west3

sudo apt-get install google-cloud-cli-gke-gcloud-auth-plugin

# Получите учетные данные для доступа к кластеру через kubectl
gcloud container clusters get-credentials hw-44-cluster --location europe-west3
```

![](screenshots/Pasted%20image%2020250903194919.png)

### 1. Изучение Namespaces:

a. Исследуйте команды Kubernetes, связанные с Namespaces, такие как создание, удаление и просмотр существующих Namespaces.

```bash
# Просмотреть все пространства имен в кластере
kubectl get namespaces # или короче kubectl get ns

# Создать новое пространство имен
kubectl create namespace my-test-namespace

# Создать Namespace через манифест YAML (create-namespace.yaml)
# apiVersion: v1
# kind: Namespace
# metadata:
#   name: my-app-namespace
kubectl apply -f create-namespace.yaml

# Удалить namespace
kubectl delete ns my-test-namespace

# Выполнить команду в конкретном namespace (например, посмотреть Pods)
kubectl get pods -n my-app-namespace
```

b. Подумайте о практических сценариях, когда использование Namespaces может быть полезным, и запишите их.

- **Изоляция сред:** `dev-namespace`, `staging-namespace`, `prod-namespace`. Это позволяет запускать разные версии одного приложения в одном кластере, экономя деньги.
- **Разделение по командам:** `team-a-namespace`, `team-b-namespace`. Каждая команда управляет своими ресурсами, не мешая другим.
- **Организация ресурсов:** Отдельные неймспейсы для мониторинга (`monitoring-ns`), логирования (`logging-ns`), CI/CD (`cicd-ns`).
- **Квоты ресурсов:** В GKE можно назначить квоты на потребление CPU/RAM для каждого неймспейса, чтобы один проект не исчерпал все ресурсы кластера.

### 2. Изучение Pods:

a. Изучите различные способы создания и манипулирования Pods, включая использование манифестов YAML или командной строки.

```bash
# 1. deployment.yaml

# 2. CLI
kubectl run my-test-pod --image=nginx --restart=Never -n my-app-namespace

```

b. Исследуйте команды для мониторинга и управления запущенными Pods.

```bash
# Посмотреть все Pods во всех namespace
kubectl get pods -A
# Посмотреть Pods в конкретном namespace
kubectl get pods -n my-app-namespace
# Посмотреть подробную информацию о Pod
kubectl describe pod my-pod-name -n my-app-namespace
# Посмотреть логи Pod
kubectl logs my-pod-name -n my-app-namespace
# Удалить Pod
kubectl delete pod my-pod-name -n my-app-namespace
# Выполнить команду внутри Pod (например, получить shell)
kubectl exec -it my-pod-name -n my-app-namespace -- /bin/bash
```


### 3. Изучение Controllers:

a. **Роль Controllers:** Они следят за тем, чтобы текущее состояние кластера (например, 2 упавших пода) соответствовало желаемому состоянию, описанному вами (например, 3 работающих пода). GKE использует их для обеспечения отказоустойчивости.

b. **Типы Controllers:**

- **ReplicaSet:** Гарантирует, что запущено определенное количество идентичных копий Pod (реплик). Обычно не используется напрямую.
- **Deployment:** Самый распространенный контроллер. Управляет ReplicaSet'ами и предоставляет механизмы обновления приложения (rolling updates, rollback) без простоев. **Идеален для stateless-приложений (веб-серверы, API).**
- **StatefulSet:** Для stateful-приложений (базы данных, Kafka, Elasticsearch), где каждому Podу нужно устойчивое сетевое имя и постоянное хранилище (Persistent Volume в GKE).

c. Команды для работы с Controllers:

```bash
# Масштабирование Deployment
kubectl scale deployment/my-app-deployment --replicas=5 -n my-app-namespace

# Обновление образа (image) в Deployment
kubectl set image deployment/my-app-deployment my-app-container=nginx:1.21 -n my-app-namespace

# Отслеживание процесса обновления
kubectl rollout status deployment/my-app-deployment -n my-app-namespace

# Откат к предыдущей версии
kubectl rollout undo deployment/my-app-deployment -n my-app-namespace

# Посмотреть историю rollout'ов
kubectl rollout history deployment/my-app-deployment -n my-app-namespace
```
### 4-7: Разработка и развертывание приложения

Создадим простое веб-приложение на Nginx в собственном неймспейсе с помощью Deployment.

**1. Создаем манифесты YAML**

`namespace.yaml`:

```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: my-app-namespace
```

`deployment.yaml` (наш Controller):

```yml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
  namespace: my-app-namespace # Указываем неймспейс!
  labels:
    app: nginx
spec:
  replicas: 3 # Желаемое количество Pods
  selector:
    matchLabels:
      app: nginx
  template: # Шаблон для создания Pods
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx-container
        image: nginx:1.25 # Используем стабильную версию
        ports:
        - containerPort: 80
```

`service.yaml` (Чтобы получить доступ к приложению извне):

```yml
apiVersion: v1
kind: Service
metadata:
  name: nginx-service
  namespace: my-app-namespace
spec:
  type: LoadBalancer # GKE создаст внешний сетевой балансировщик нагрузки
  selector:
    app: nginx # Выбираем все Pods с этим лейблом
  ports:
    - protocol: TCP
      port: 80 # Порт, на котором Service принимает запросы
      targetPort: 80 # Порт, на который перенаправлять запросы в Pod
```

**2. Применяем манифесты и запускаем приложение**

```bash
# Применяем все конфиги
kubectl apply -f namespace.yaml
kubectl apply -f deployment.yaml
kubectl apply -f service.yaml

# Проверяем, что все создалось
kubectl get all -n my-app-namespace
```

![](screenshots/Pasted%20image%2020250903203808.png)

**3. Проверяем работу приложения**

```bash
kubectl get service nginx-service -n my-app-namespace
```

![](screenshots/Pasted%20image%2020250903205734.png)

![](screenshots/Pasted%20image%2020250903203937.png)
### 8.  Мониторинг, масштабирование и управление 

```bash
# Мониторинг
kubectl get pods -n my-app-namespace -w # Следить за состоянием Pods в реальном времени
kubectl top pods -n my-app-namespace # Потребление CPU/RAM (должен быть установлен metrics-server, в GKE он есть по умолчанию)
```

```bash
# Масштабирование
kubectl scale deployment/nginx-deployment --replicas=5 -n my-app-namespace
kubectl get pods -n my-app-namespace # Убедитесь, что стало 5 Pods
```
![](screenshots/Pasted%20image%2020250903204610.png)

![](screenshots/Pasted%20image%2020250903204637.png)

```bash

# Обновление (симуляция выкатки новой версии)
kubectl set image deployment/nginx-deployment nginx-container=nginx:1.26 -n my-app-namespace
kubectl rollout status deployment/nginx-deployment -n my-app-namespace # Следим за процессом

# Если что-то пошло не так - откатываемся
kubectl rollout undo deployment/nginx-deployment -n my-app-namespace
```

![](screenshots/Pasted%20image%2020250903205129.png)

Проверка версии `nginx` :

![](screenshots/Pasted%20image%2020250903205237.png)